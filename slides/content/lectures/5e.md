---
title: "x5 deserialization and pp"
layout: "bundle"
outputs: ["Reveal"]
---

## We'll get started at 20:05

---

{{< slide class="center" >}}
## deserialization && prototype pollution
### 6843 week5

---

{{% section %}}
## serialization

---

### what is serialization
* converting an object's state (data/structure) into a format that can be stored/transmitted.
* relatively straight-forward for simple types (e.g. strings, numbers), not so much others.
* all code is constantly serialized and stored in memory.

---

### can anyone think of examples of serialization
* writing data to files
  * csv
  * json
* storing stuff in a database
* sending data over a network
* a webserver receiving traffic 
* protobufs!!1

---

### is this exploitable
* not necessarily that dangerous
* this is control > data
* you're turning structures into some format

{{% /section %}}

---

{{% section %}}

## deserialization

---
### what is it
* as expected, the opposite of serialization
* turning serialized data (e.g. a string) back into code/data structures/objects
* this is data > control

---

### type confusion
> when a program misinterprets the type of data its being provided

* this can cause crashes, memory corruption, unexpected behaviour (**the good stuff**)
* what if the program expects a specific type of object during deserialization, but receives something else


{{% /section %}}

---

{{% section %}}

I turned myself into a
## python pickle

---

### example usage
```
import pickle

class User:
    def __init__(self, name):
        self.name = name

user = User("Alice")
serialized_data = pickle.dumps(user)

deserialized_user = pickle.loads(serialized_data)
print(deserialized_user.name)
```

---

### ?

---

### demo

---

### how does that work
> To the [docs](https://docs.python.org/2/library/pickle.html#pickling-and-unpickling-extension-types).
* Not every object will serialize well ([e.g. file handles](https://stackoverflow.com/a/19874769)).
* This is the user's way of specifying how to deserialize non-simple types.

{{% /section %}}

---

{{% section %}}
## prototype pollution

---

### inheritance
* for compiled languages like java, relationships are well-defined at **compile time**
* for interpreted languages, these relationships must be able to change at **runtime**

---

### kinda similar to mro in python
* javascript doesn't have traditional class-based multiple inheritance
* instead it has prototype chaining (& mixins)
* **all objects lead back to the same prototype**

---

### how are attributes resolved?
1. own properties
2. its prototype ("parent")
3. its prototypes prototype
4. so on
similarly
---

### how to exploit this?
* what if we changed the prototype of one object
* would it [ae]ffect others?

```
Object.prototype.test = "This is dangerous!";

const obj = {};
console.log(obj.test); // "This is dangerous!"
```

what about:
```
let a = {}, b = {}
a.__proto__.test = 123

console.log(b.test); // 123
```

---

### demo

{{% /section %}}

---

{{% section %}}

## log4j

---

### 

---

### meme: an aside
how was it discovered
* It existed since 2013
* Idk if it's true, but I've heard it was first exploited against Minecraft servers
* [quick fix](https://github.com/apache/logging-log4j2/pull/608)

---

### per a random person on ycombinator
```
Nov 24 - Wednesday - Report of issue
Nov 25 - Thursday  - Thanksgiving
Nov 29 - Monday    - Work done
Nov 30 - Tuesday   - PR submitted
Dec  9 - Thursday  - "Is it a security vulnerability?"
Dec 10 - Friday    - All hell breaks loose (Log4j 2.15.0 released)
Dec 13 - Monday    - Java devs updating libraries furiously (Log4j 2.16.0 released)
Dec 18 - Saturday  - Wait? there's more (Log4j 2.17.0 released)
...
Dec 27 - Monday    - Enough already (Log4j 2.17.1 released)
```

{{% /section %}}
